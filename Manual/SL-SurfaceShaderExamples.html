<!DOCTYPE html><html lang="en" class="no-js">
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Unity - Manual: Surface Shader Examples</title>
<meta name="description" content="Develop once, publish everywhere! Unity is the ultimate tool for video game development, architectural visualizations, and interactive media installations - publish to the web, Windows, OS X, Wii, Xbox 360, and iPhone with many more platforms to come.">
<meta name="author" content="Unity Technologies">
<link rel="shortcut icon" href="../StaticFilesManual/images/favicons/favicon.ico">
<link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png">
<meta name="msapplication-TileColor" content="#222c37">
<meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png">
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2854981-1']);
  _gaq.push(['_setDomainName', 'unity3d.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  </script><script type="text/javascript" src="../StaticFilesManual/js/jquery.js"></script><script type="text/javascript" src="../StaticFilesManual/js/core.js"></script><script type="text/javascript" src="../StaticFilesManual/js/highlight.js"></script><script type="text/javascript" src="docdata/toc.js"></script><script type="text/javascript" src="docdata/global_toc.js"></script><script>hljs.initHighlightingOnLoad();</script><link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700,400italic" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css">
</head>
<body>
<div class="header-wrapper">
<div id="header" class="header"><div class="content">
<div class="spacer"><div class="menu">
<div class="logo"><a href="http://docs.unity3d.com"></a></div>
<div class="search-form"><form action="30_search.html" method="get" class="apisearch">
<input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"><input type="submit" class="submit">
</form></div>
<ul>
<li><a href="http://docs.unity3d.com">Overview</a></li>
<li><a href="../Manual/index.html" class="selected">Manual</a></li>
<li><a href="../ScriptReference/index.html">Scripting API</a></li>
</ul>
</div></div>
<div class="more">
<div class="filler"></div>
<ul><li><a href="http://unity3d.com/">unity3d.com</a></li></ul>
</div>
</div></div>
<div class="toolbar"><div class="content"><div class="lang-switcher">
<div class="current toggle" data-target=".lang-list">
<div class="lbl">Language: <span class="b">English</span>
</div>
<div class="arrow"></div>
</div>
<div class="lang-list" style="display:none;"><ul>
<li><a href="/Manual/SL-SurfaceShaderExamples.html">English</a></li>
<li><a href="/es/current/Manual/SL-SurfaceShaderExamples.html">Español</a></li>
<li><a href="/ru/current/Manual/SL-SurfaceShaderExamples.html">Русский</a></li>
</ul></div>
</div></div></div>
</div>
<div id="master-wrapper" class="master-wrapper clear">
<div id="sidebar" class="sidebar"><div class="sidebar-wrap"><div class="content"><div class="sidebar-menu"><div class="toc"><h2>Unity Manual</h2></div></div></div></div></div>
<div id="content-wrap" class="content-wrap"><div class="content-block"><div class="content">
<div class="section">
<div class="breadcrumbs clear"><ul>
<li><a href="UnityManualRestructured.html">Unity Manual</a></li>
<li><a href="Graphics.html">Graphics</a></li>
<li><a href="GraphicsReference.html">Graphics Reference</a></li>
<li><a href="SL-Reference.html"> Shader Reference</a></li>
<li><a href="SL-SurfaceShaders.html"> Writing Surface Shaders</a></li>
<li>Surface Shader Examples</li>
</ul></div>
<div class="mb20"><div class="nextprev clear">
<div class="icon tt left mr1" data-distance="-40|-30|top">
<span class="prev"><a href="SL-SurfaceShaders.html"></a></span><div class="tip"> Writing Surface Shaders</div>
</div>
<div class="icon tt right" data-distance="-40|-30|top">
<span class="next"><a href="SL-SurfaceShaderLighting.html"></a></span><div class="tip">Custom Lighting models in Surface Shaders</div>
</div>
</div></div>
<h1>Surface Shader Examples</h1>
  		        <div class="suggest">
                <a class="blue-btn sbtn">Suggest a change</a>
                <div class="suggest-wrap rel hide">
                  <div class="loading hide">
<div></div>
<div></div>
<div></div>
</div>
                  <div class="suggest-success hide">
                    <h2>Success!</h2>
                    <p>Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable.</p>
                    <a class="gray-btn sbtn close">Close</a>
                  </div>
                  <div class="suggest-failed hide">
                    <h2>Sumbission failed</h2>
                    <p>For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation.</p>
                    <a class="gray-btn sbtn close">Close</a>
                  </div>
                  <div class="suggest-form clear">
                    <label for="suggest_name">Your name</label>
                    <input id="suggest_name" type="text">
                    <label for="suggest_email">Your email</label>
                    <input id="suggest_email" type="email">
                    <label for="suggest_body" class="clear">Suggestion <span class="r">*</span></label>
                    <textarea id="suggest_body" class="req"></textarea>
                    <button id="suggest_submit" class="blue-btn mr10">Submit suggestion</button>
                    <p class="mb0"><a class="cancel left lh42 cn">Cancel</a></p>
                  </div>
                </div>
              </div>
<!--BeginSwitchLink--><!--EndSwitchLink-->
<div class="clear"></div>

<p>Here are some examples of <a href="SL-SurfaceShaders.html"><span class="doc-keyword">Surface Shaders</span></a>. The examples below focus on using built-in lighting models; examples on how to implement custom lighting models are in <a href="SL-SurfaceShaderLightingExamples.html">Surface Shader Lighting Examples</a>.</p>

<h2>Simple</h2>

<p>We’ll start with a very simple shader and build up on that. Here’s a shader that just sets surface color to “white”. It uses built-in Lambert (diffuse) lighting model.</p>

<pre><code>  Shader &quot;Example/Diffuse Simple&quot; {
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float4 color : COLOR;
      };
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = 1;
      }
      ENDCG
    }
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<p>Here’s how it looks like on a model with two <a href="class-Light.html">lights</a> set up: </p>

<figure>
<img src="../uploads/Main/SurfaceShaderSimple.png" alt="">
<figcaption></figcaption></figure>

<h2>Texture</h2>

<p>An all-white object is quite boring, so let’s add a texture. We’ll add a <a href="SL-Properties.html">Properties block</a> to the shader, so we get a texture selector in our Material. Other changes are in bold below.</p>

<pre><code>  Shader &quot;Example/Diffuse Texture&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
      };
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderDiffuseTex.png" alt="">
<figcaption></figcaption></figure>

<h2>Normal mapping</h2>

<p>Let’s add some normal mapping:</p>

<pre><code>  Shader &quot;Example/Diffuse Bump&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _BumpMap (&quot;Bumpmap&quot;, 2D) = &quot;bump&quot; {}
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
        float2 uv_MainTex;
        float2 uv_BumpMap;
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      void surf (Input IN, inout SurfaceOutput o) {
        o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
        o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderDiffuseBump.png" alt="">
<figcaption></figcaption></figure>

<h2>Rim Lighting</h2>

<p>Now, try to add some Rim Lighting to highlight the edges of an object. We’ll add some emissive light based on angle between surface normal and view direction. For that, we’ll use <code>viewDir</code> built-in surface shader variable.</p>

<pre><code>  Shader &quot;Example/Rim&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _BumpMap (&quot;Bumpmap&quot;, 2D) = &quot;bump&quot; {}
      _RimColor (&quot;Rim Color&quot;, Color) = (0.26,0.19,0.16,0.0)
      _RimPower (&quot;Rim Power&quot;, Range(0.5,8.0)) = 3.0
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float2 uv_BumpMap;
          float3 viewDir;
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      float4 _RimColor;
      float _RimPower;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
          half rim = 1.0 - saturate(dot (normalize(IN.viewDir), o.Normal));
          o.Emission = _RimColor.rgb * pow (rim, _RimPower);
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderRim.png" alt="">
<figcaption></figcaption></figure>

<h2>Detail Texture</h2>

<p>For a different effect, let’s add a detail texture that is combined with the base texture. Detail texture uses the same UVs, but usually different Tiling in the Material, so we have to use different input UV coordinates.</p>

<pre><code>  Shader &quot;Example/Detail&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _BumpMap (&quot;Bumpmap&quot;, 2D) = &quot;bump&quot; {}
      _Detail (&quot;Detail&quot;, 2D) = &quot;gray&quot; {}
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float2 uv_BumpMap;
          float2 uv_Detail;
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      sampler2D _Detail;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          o.Albedo *= tex2D (_Detail, IN.uv_Detail).rgb * 2;
          o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<p>Using a checker texture does not make much practical sense, but illustrates what happens: </p>

<figure>
<img src="../uploads/Main/SurfaceShaderDetailTex.png" alt="">
<figcaption></figcaption></figure>

<h2>Detail Texture in Screen Space</h2>

<p>How about a detail texture in screen space? It does not make much sense for a soldier head model, but illustrates how a built-in <code>screenPos</code> input might be used:</p>

<pre><code>  Shader &quot;Example/ScreenPos&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _Detail (&quot;Detail&quot;, 2D) = &quot;gray&quot; {}
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float4 screenPos;
      };
      sampler2D _MainTex;
      sampler2D _Detail;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          float2 screenUV = IN.screenPos.xy / IN.screenPos.w;
          screenUV *= float2(8,6);
          o.Albedo *= tex2D (_Detail, screenUV).rgb * 2;
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<p>The normal mapping has been removed from the shader above, just to make it shorter: </p>

<figure>
<img src="../uploads/Main/SurfaceShaderDetailTexScreenPos.png" alt="">
<figcaption></figcaption></figure>

<h2>Cubemap Reflection</h2>

<p>Here’s a shader that does cubemapped reflection using built-in <code>worldRefl</code> input. It’s actually very similar to built-in Reflective/Diffuse shader:</p>

<pre><code>  Shader &quot;Example/WorldRefl&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _Cube (&quot;Cubemap&quot;, CUBE) = &quot;&quot; {}
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float3 worldRefl;
      };
      sampler2D _MainTex;
      samplerCUBE _Cube;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb * 0.5;
          o.Emission = texCUBE (_Cube, IN.worldRefl).rgb;
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<p>And since it assigns the reflection color as Emission, we get a very shiny soldier: </p>

<figure>
<img src="../uploads/Main/SurfaceShaderWorldRefl.png" alt="">
<figcaption></figcaption></figure>

<p>If you want to do reflections that are affected by normal maps, it needs to be slightly more involved: <code>INTERNAL_DATA</code> needs to be added to the Input structure, and <code>WorldReflectionVector</code> function used to compute per-pixel reflection vector after you’ve written the Normal output.</p>

<pre><code>  Shader &quot;Example/WorldRefl Normalmap&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _BumpMap (&quot;Bumpmap&quot;, 2D) = &quot;bump&quot; {}
      _Cube (&quot;Cubemap&quot;, CUBE) = &quot;&quot; {}
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float2 uv_BumpMap;
          float3 worldRefl;
          INTERNAL_DATA
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      samplerCUBE _Cube;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb * 0.5;
          o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
          o.Emission = texCUBE (_Cube, WorldReflectionVector (IN, o.Normal)).rgb;
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<p>Here’s a normal mapped shiny soldier: </p>

<figure>
<img src="../uploads/Main/SurfaceShaderWorldReflNormalmap.png" alt="">
<figcaption></figcaption></figure>

<h2>Slices via World Space Position</h2>

<p>Here’s a shader that “slices” the object by discarding pixels in nearly horizontal rings. It does that by using <code>clip()</code> Cg/HLSL function based on world position of a pixel. We’ll use <code>worldPos</code> built-in surface shader variable.</p>

<pre><code>  Shader &quot;Example/Slices&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _BumpMap (&quot;Bumpmap&quot;, 2D) = &quot;bump&quot; {}
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      Cull Off
      CGPROGRAM
      #pragma surface surf Lambert
      struct Input {
          float2 uv_MainTex;
          float2 uv_BumpMap;
          float3 worldPos;
      };
      sampler2D _MainTex;
      sampler2D _BumpMap;
      void surf (Input IN, inout SurfaceOutput o) {
          clip (frac((IN.worldPos.y+IN.worldPos.z*0.1) * 5) - 0.5);
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderSlices.png" alt="">
<figcaption></figcaption></figure>

<h2>Normal Extrusion with Vertex Modifier</h2>

<p>It is possible to use a “vertex modifier” function that will modify incoming vertex data in the vertex shader. This can be used for procedural animation, extrusion along normals and so on. Surface shader compilation directive <code>vertex:functionName</code> is used for that, with a function that takes <code>inout appdata_full</code> parameter.</p>

<p>Here’s a shader that moves vertices along their normals by the amount specified in the material:</p>

<pre><code>  Shader &quot;Example/Normal Extrusion&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _Amount (&quot;Extrusion Amount&quot;, Range(-1,1)) = 0.5
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert vertex:vert
      struct Input {
          float2 uv_MainTex;
      };
      float _Amount;
      void vert (inout appdata_full v) {
          v.vertex.xyz += v.normal * _Amount;
      }
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<p>Moving vertices along their normals makes a fat soldier: </p>

<figure>
<img src="../uploads/Main/SurfaceShaderNormalExtrusion.png" alt="">
<figcaption></figcaption></figure>

<h2>Custom data computed per-vertex</h2>

<p>Using a vertex modifier function it is also possible to compute custom data in a vertex shader, which then will be passed to the surface shader function per-pixel. The same compilation directive <code>vertex:functionName</code> is used, but the function should take two parameters: <code>inout appdata_full</code> and <code>out Input</code>. You can fill in any Input member that is not a built-in value there.</p>

<p>
<strong>Note:</strong> Custom Input members used in this way must not have names beginning with ‘uv’ or they won’t work properly.</p>

<p>The example below defines a custom <code>float3 customColor</code> member, which is computed in a vertex function:</p>

<pre><code>  Shader &quot;Example/Custom Vertex Data&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert vertex:vert
      struct Input {
          float2 uv_MainTex;
          float3 customColor;
      };
      void vert (inout appdata_full v, out Input o) {
          UNITY_INITIALIZE_OUTPUT(Input,o);
          o.customColor = abs(v.normal);
      }
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          o.Albedo *= IN.customColor;
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<p>In this example <code>customColor</code> is set to the absolute value of the normal: </p>

<figure>
<img src="../uploads/Main/SurfaceShaderCustomVertexData.png" alt="">
<figcaption></figcaption></figure>

<p>More practical uses could be computing any per-vertex data that is not provided by built-in Input variables; or optimizing shader computations. For example, it’s possible to compute Rim lighting at object’s vertices, instead of doing that in the surface shader per-pixel.</p>

<h2>Final Color Modifier</h2>

<p>It is possible to use a “final color modifier” function that will modify final color computed by the shader. Surface shader compilation directive <code>finalcolor:functionName</code> is used for that, with a function that takes <code>Input IN, SurfaceOutput o, inout fixed4 color</code> parameters.</p>

<p>Here’s a simple shader that applies tint to final color. This is different from just applying tint to surface Albedo color: this tint will also affect any color that came from lightmaps, light probes and similar extra sources.</p>

<pre><code>  Shader &quot;Example/Tint Final Color&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _ColorTint (&quot;Tint&quot;, Color) = (1.0, 0.6, 0.6, 1.0)
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert finalcolor:mycolor
      struct Input {
          float2 uv_MainTex;
      };
      fixed4 _ColorTint;
      void mycolor (Input IN, SurfaceOutput o, inout fixed4 color)
      {
          color *= _ColorTint;
      }
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
           o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderFinalColorSimple.png" alt="">
<figcaption></figcaption></figure>

<h2>Custom Fog with Final Color Modifier</h2>

<p>Common use case for final color modifier (see above) would be implementing completely custom Fog. Fog needs to affect the final computed pixel shader color, which is exactly what the <code>finalcolor</code> modifier does.</p>

<p>Here’s a shader that applies fog tint based on distance from screen center. This combines both the vertex modifier with custom vertex data (<code>fog</code>) and final color modifier. When used in forward rendering additive pass, Fog needs to fade to black color, and this example handles that as well with a check for <code>UNITY_PASS_FORWARDADD</code>.</p>

<pre><code>  Shader &quot;Example/Fog via Final Color&quot; {
    Properties {
      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
      _FogColor (&quot;Fog Color&quot;, Color) = (0.3, 0.4, 0.7, 1.0)
    }
    SubShader {
      Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
      CGPROGRAM
      #pragma surface surf Lambert finalcolor:mycolor vertex:myvert
      struct Input {
          float2 uv_MainTex;
          half fog;
      };
      void myvert (inout appdata_full v, out Input data)
      {
          UNITY_INITIALIZE_OUTPUT(Input,data);
          float4 hpos = mul (UNITY_MATRIX_MVP, v.vertex);
          data.fog = min (1, dot (hpos.xy, hpos.xy) * 0.1);
      }
      fixed4 _FogColor;
      void mycolor (Input IN, SurfaceOutput o, inout fixed4 color)
      {
          fixed3 fogColor = _FogColor.rgb;
          #ifdef UNITY_PASS_FORWARDADD
          fogColor = 0;
          #endif
          color.rgb = lerp (color.rgb, fogColor, IN.fog);
      }
      sampler2D _MainTex;
      void surf (Input IN, inout SurfaceOutput o) {
           o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
      }
      ENDCG
    } 
    Fallback &quot;Diffuse&quot;
  }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderFinalColorFog.png" alt="">
<figcaption></figcaption></figure>

<h2>Linear Fog</h2>

<pre><code>Shader &quot;Example/Linear Fog&quot; {
  Properties {
    _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {}
  }
  SubShader {
    Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
    LOD 200
    
    CGPROGRAM
    #pragma surface surf Lambert finalcolor:mycolor vertex:myvert

    sampler2D _MainTex;
    uniform half4 unity_FogColor;
    uniform half4 unity_FogStart;
    uniform half4 unity_FogEnd;

    struct Input {
      float2 uv_MainTex;
      half fog;
    };

    void myvert (inout appdata_full v, out Input data) {
      UNITY_INITIALIZE_OUTPUT(Input,data);
      float pos = length(mul (UNITY_MATRIX_MV, v.vertex).xyz);
      float diff = unity_FogEnd.x - unity_FogStart.x;
      float invDiff = 1.0f / diff;
      data.fog = clamp ((unity_FogEnd.x - pos) * invDiff, 0.0, 1.0);
    }
    void mycolor (Input IN, SurfaceOutput o, inout fixed4 color) {
      fixed3 fogColor = unity_FogColor.rgb;
      #ifdef UNITY_PASS_FORWARDADD
      fogColor = 0;
      #endif
      color.rgb = lerp (fogColor, color.rgb, IN.fog);
    }

    void surf (Input IN, inout SurfaceOutput o) {
      half4 c = tex2D (_MainTex, IN.uv_MainTex);
      o.Albedo = c.rgb;
      o.Alpha = c.a;
    }
    ENDCG
  } 
  FallBack &quot;Diffuse&quot;
}
</code></pre>
<div class="nextprev clear">
<div class="icon tt left mr1" data-distance="-40|-30|top">
<span class="prev"><a href="SL-SurfaceShaders.html"></a></span><div class="tip"> Writing Surface Shaders</div>
</div>
<div class="icon tt right" data-distance="-40|-30|top">
<span class="next"><a href="SL-SurfaceShaderLighting.html"></a></span><div class="tip">Custom Lighting models in Surface Shaders</div>
</div>
</div>
</div>
<div class="footer-wrapper"><div class="footer clear">
<div class="copy">Copyright © 2014 Unity Technologies</div>
<div class="menu">
<a href="http://unity3d.com/learn">Learn</a><a href="http://unity3d.com/community">Community</a><a href="http://unity3d.com/asset-store">Asset Store</a><a href="https://store.unity3d.com">Buy</a><a href="http://unity3d.com/unity/download">Download</a>
</div>
</div></div>
</div></div></div>
</div>
</body>
</html>
